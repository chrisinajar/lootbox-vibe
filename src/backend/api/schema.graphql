scalar BigInt

enum Rarity { COMMON UNCOMMON RARE EPIC LEGENDARY MYTHIC }

type CountByRarity { rarity: Rarity!, count: BigInt! }
type CountByType   { typeId: ID!, count: BigInt! }
type CountBySource { sourceBoxId: ID!, count: BigInt! }

type InventorySummary {
  totalStacks: Int!
  totalItems: BigInt!
  byRarity: [CountByRarity!]!
  byType: [CountByType!]!
  bySource: [CountBySource!]!
}

type Query {
  inventorySummary: InventorySummary!
  inventoryList(filter: InventoryFilter, limit: Int = 100, cursor: ID): PageItemStacks!
  configHash: String!
  currencies: [CurrencyBalance!]!
  unlockedBoxes: [ID!]!
  collectionLog: CollectionLog!
  shop: ShopState!
  availableBoxes: [BoxInfo!]!
  boxCatalog: [BoxInfo!]!
  materialsCatalog: [MaterialInfo!]!
}

input OpenBoxesInput { boxId: ID!, count: Int!, requestId: ID! }

type RewardStack { stackId: ID!, typeId: ID!, rarity: Rarity!, count: Int! }
type RewardCurrency { currency: ID!, amount: BigInt! }
type Rewards { stacks: [RewardStack!]!, currencies: [RewardCurrency!]!, unlocks: [ID!]! }

type Mutation { openBoxes(input: OpenBoxesInput!): Rewards! }

input SalvageInput { maxRarity: Rarity!, typeIds: [ID!], staticModIds: [ID!] }
type SalvageResult { scrapped: [RewardStack!]!, currencies: [RewardCurrency!]! }

extend type Mutation { salvage(input: SalvageInput!): SalvageResult! }

# Idle claim
input ClaimIdleInput { noop: Boolean }
type IdleReport { message: String!, boxesOpened: Int!, rewards: Rewards! }
extend type Mutation { claimIdle(input: ClaimIdleInput): IdleReport! }

# Inventory list types
input InventoryFilter { rarity: Rarity, typeId: ID, sourceBoxId: ID, curatedTags: [ID!] }
type ItemStack { stackId: ID!, typeId: ID!, rarity: Rarity!, count: Int! }
type PageItemStacks { rows: [ItemStack!]!, nextCursor: ID }

# Currency balances
type CurrencyBalance { currency: ID!, amount: BigInt! }

# Collection log types
type CollectionItem {
  id: ID!
  name: String!
  typeId: ID!
  rarity: Rarity!
  hint: String
  hasCosmetic: Boolean!
  hasMechanical: Boolean!
  discovered: Boolean!
}
type CountProgress { key: ID!, discovered: Int!, total: Int! }
type CollectionLog { items: [CollectionItem!]!, byRarity: [CountProgress!]!, byType: [CountProgress!]! }

# Box info for selection UI
type BoxInfo { id: ID!, name: String!, cost: Int! }
type MaterialInfo { id: ID!, name: String! }

# Shop & upgrades
type Upgrade { id: ID!, name: String!, desc: String!, costScrap: Int!, purchased: Boolean! }
type ExchangeInfo { id: ID!, from: ID!, to: ID!, rateFrom: Int!, rateTo: Int!, mintedToday: Int!, dailyCapTo: Int! }
type ShopState { upgrades: [Upgrade!]!, exchange: ExchangeInfo! }

input PurchaseUpgradeInput { upgradeId: ID! }
extend type Mutation { purchaseUpgrade(input: PurchaseUpgradeInput!): ShopState! }

input ExchangeInput { toAmount: Int! }
extend type Mutation { exchangeScrapToKeys(input: ExchangeInput!): ShopState! }

# Progression & idle
type Milestone { id: ID!, label: String!, target: Int!, current: Int!, unlocked: Boolean! }
type RngUnlock { id: ID!, label: String!, discovered: Boolean! }
type Progression { milestones: [Milestone!]!, rng: [RngUnlock!]! }
type IdleClaim { message: String!, boxesOpened: Int! }
extend type Query { progression: Progression! }
